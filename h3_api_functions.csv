"FunctionName","Parameters","ReturnType"
"latLngToCell","g (const LatLng *); res (int); out (H3Index *)","H3Error"
"cellToLatLng","h3 (H3Index); g (LatLng *)","H3Error"
"cellToBoundary","h3 (H3Index); gp (CellBoundary *)","H3Error"
"maxGridDiskSize","k (int); out (int64_t *)","H3Error"
"gridDiskUnsafe","origin (H3Index); k (int); out (H3Index *)","H3Error"
"gridDiskDistancesUnsafe","origin (H3Index); k (int); out (H3Index *); distances (int *)","H3Error"
"gridDiskDistancesSafe","origin (H3Index); k (int); out (H3Index *); distances (int *)","H3Error"
"gridDisksUnsafe","h3Set (H3Index *); length (int); k (int); out (H3Index *)","H3Error"
"gridDisk","origin (H3Index); k (int); out (H3Index *)","H3Error"
"gridDiskDistances","origin (H3Index); k (int); out (H3Index *); distances (int *)","H3Error"
"gridRingUnsafe","origin (H3Index); k (int); out (H3Index *)","H3Error"
"maxPolygonToCellsSize","geoPolygon (const GeoPolygon *); res (int); flags (uint32_t); out (int64_t *)","H3Error"
"polygonToCells","geoPolygon (const GeoPolygon *); res (int); flags (uint32_t); out (H3Index *)","H3Error"
"maxPolygonToCellsSizeExperimental","polygon (const GeoPolygon *); res (int); flags (uint32_t); out (int64_t *)","H3Error"
"polygonToCellsExperimental","polygon (const GeoPolygon *); res (int); flags (uint32_t); size (int64_t); out (H3Index *)","H3Error"
"cellsToLinkedMultiPolygon","h3Set (const H3Index *); numHexes (const int); out (LinkedGeoPolygon *)","H3Error"
"destroyLinkedMultiPolygon","polygon (LinkedGeoPolygon *)","void"
"degsToRads","degrees (double)","double"
"radsToDegs","radians (double)","double"
"greatCircleDistanceRads","a (const LatLng *); b (const LatLng *)","double"
"greatCircleDistanceKm","a (const LatLng *); b (const LatLng *)","double"
"greatCircleDistanceM","a (const LatLng *); b (const LatLng *)","double"
"getHexagonAreaAvgKm2","res (int); out (double *)","H3Error"
"getHexagonAreaAvgM2","res (int); out (double *)","H3Error"
"cellAreaRads2","h (H3Index); out (double *)","H3Error"
"cellAreaKm2","h (H3Index); out (double *)","H3Error"
"cellAreaM2","h (H3Index); out (double *)","H3Error"
"getHexagonEdgeLengthAvgKm","res (int); out (double *)","H3Error"
"getHexagonEdgeLengthAvgM","res (int); out (double *)","H3Error"
"edgeLengthRads","edge (H3Index); length (double *)","H3Error"
"edgeLengthKm","edge (H3Index); length (double *)","H3Error"
"edgeLengthM","edge (H3Index); length (double *)","H3Error"
"getNumCells","res (int); out (int64_t *)","H3Error"
"res0CellCount","","int"
"getRes0Cells","out (H3Index *)","H3Error"
"pentagonCount","","int"
"getPentagons","res (int); out (H3Index *)","H3Error"
"getResolution","h (H3Index)","int"
"getBaseCellNumber","h (H3Index)","int"
"stringToH3","str (const char *); out (H3Index *)","H3Error"
"h3ToString","h (H3Index); str (char *); sz (size_t)","H3Error"
"isValidCell","h (H3Index)","int"
"cellToParent","h (H3Index); parentRes (int); parent (H3Index *)","H3Error"
"cellToChildrenSize","h (H3Index); childRes (int); out (int64_t *)","H3Error"
"cellToChildren","h (H3Index); childRes (int); children (H3Index *)","H3Error"
"cellToCenterChild","h (H3Index); childRes (int); child (H3Index *)","H3Error"
"cellToChildPos","child (H3Index); parentRes (int); out (int64_t *)","H3Error"
"childPosToCell","childPos (int64_t); parent (H3Index); childRes (int); child (H3Index *)","H3Error"
"compactCells","h3Set (const H3Index *); compactedSet (H3Index *); numHexes (const int64_t)","H3Error"
"uncompactCellsSize","compactedSet (const H3Index *); numCompacted (const int64_t); res (const int); out (int64_t *)","H3Error"
"uncompactCells","compactedSet (const H3Index *); numCompacted (const int64_t); outSet (H3Index *); numOut (const int64_t); res (const int)","H3Error"
"isResClassIII","h (H3Index)","int"
"isPentagon","h (H3Index)","int"
"maxFaceCount","h3 (H3Index); out (int *)","H3Error"
"getIcosahedronFaces","h3 (H3Index); out (int *)","H3Error"
"areNeighborCells","origin (H3Index); destination (H3Index); out (int *)","H3Error"
"cellsToDirectedEdge","origin (H3Index); destination (H3Index); out (H3Index *)","H3Error"
"isValidDirectedEdge","edge (H3Index)","int"
"getDirectedEdgeOrigin","edge (H3Index); out (H3Index *)","H3Error"
"getDirectedEdgeDestination","edge (H3Index); out (H3Index *)","H3Error"
"directedEdgeToCells","edge (H3Index); originDestination (H3Index *)","H3Error"
"originToDirectedEdges","origin (H3Index); edges (H3Index *)","H3Error"
"directedEdgeToBoundary","edge (H3Index); gb (CellBoundary *)","H3Error"
"cellToVertex","origin (H3Index); vertexNum (int); out (H3Index *)","H3Error"
"cellToVertexes","origin (H3Index); vertexes (H3Index *)","H3Error"
"vertexToLatLng","vertex (H3Index); point (LatLng *)","H3Error"
"isValidVertex","vertex (H3Index)","int"
"gridDistance","origin (H3Index); h3 (H3Index); distance (int64_t *)","H3Error"
"gridPathCellsSize","start (H3Index); end (H3Index); size (int64_t *)","H3Error"
"gridPathCells","start (H3Index); end (H3Index); out (H3Index *)","H3Error"
"cellToLocalIj","origin (H3Index); h3 (H3Index); mode (uint32_t); out (CoordIJ *)","H3Error"
"localIjToCell","origin (H3Index); ij (const CoordIJ *); mode (uint32_t); out (H3Index *)","H3Error"